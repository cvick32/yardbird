;; VMT file demonstrating list copying
;; Converted from array_copy.vmt
;; Property: After copying list a to list b, they are equal at all positions

(declare-sort ListInt 0)

;; Source and destination lists
(declare-fun a () ListInt)
(declare-fun a_next () ListInt)
(define-fun .a () ListInt (! a :next a_next))

(declare-fun b () ListInt)
(declare-fun b_next () ListInt)
(define-fun .b () ListInt (! b :next b_next))

;; Counter for iteration
(declare-fun i () Int)
(declare-fun i_next () Int)
(define-fun .i () Int (! i :next i_next))

;; List length
(declare-fun n () Int)
(declare-fun n_next () Int)
(define-fun .n () Int (! n :next n_next))

;; Test position
(declare-fun Z () Int)
(declare-fun Z_next () Int)
(define-fun .Z () Int (! Z :next Z_next))

;; List operations
(declare-fun nil () ListInt)
(declare-fun cons (Int ListInt) ListInt)
(declare-fun nth (ListInt Int) Int)
(declare-fun update-nth (ListInt Int Int) ListInt)
(declare-fun length (ListInt) Int)

;; Initial conditions
(define-fun init-conditions () Bool (!
  (and
    (= i 0)
    ;; Lists have initial content
    (= (length a) n)
    (= (length b) n)
  )
  :init true))

;; Transition relation
(define-fun trans-conditions () Bool (!
  (and
    ;; Copy element from a[i] to b[i]
    (= b_next (update-nth b i (nth a i)))
    (< i n)
    (= i_next (+ i 1))
    (= a_next a)  ;; source list doesn't change
    (= n_next n)
    (= Z_next Z)
  )
  :trans true))

;; Property: After copying, both lists are equal at any valid position Z
(define-fun property () Bool (!
  (=> (and (>= i n) (>= Z 0) (< Z n))
      (= (nth a Z) (nth b Z)))
  :invar-property 0))