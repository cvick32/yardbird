;; VMT file demonstrating list copying using functional approach
;; Property: After copying list a to list b, they are structurally equal

(declare-sort ListInt 0)

;; Source list (remains constant)
(declare-fun a () ListInt)
(declare-fun a_next () ListInt)
(define-fun .a () ListInt (! a :next a_next))

;; Destination list (being built)
(declare-fun b () ListInt)
(declare-fun b_next () ListInt)
(define-fun .b () ListInt (! b :next b_next))

;; Current list being processed (tail of original)
(declare-fun curr () ListInt)
(declare-fun curr_next () ListInt)
(define-fun .curr () ListInt (! curr :next curr_next))

(declare-fun Z () Int)
(declare-fun Z_next () Int)
(define-fun .Z () Int (! Z :next Z_next))

;; List operations - only use grounded primitives
(declare-fun nil () ListInt)
(declare-fun cons (Int ListInt) ListInt)
(declare-fun head (ListInt) Int)
(declare-fun tail (ListInt) ListInt)
(declare-fun length (ListInt) Int)
(declare-fun is-nil (ListInt) Bool)

;; Initial conditions
(define-fun init-conditions () Bool (!
  (and
    ;; Start with empty destination list
    (= b nil)
    ;; Current processing starts with the source list
    (= curr a)
    (not (is-nil a))
  )
  :init true))

;; Transition relation: functional copying by reconstruction
(define-fun trans-conditions () Bool (!
  (and
    ;; Only proceed if current list is not empty
    (not (is-nil curr))
    ;; Build destination by prepending head of current to existing b
    (= b_next (cons (head curr) b))
    ;; Move to tail of current list
    (= curr_next (tail curr))
    ;; Source list never changes
    (= a_next a)
    (= Z_next Z)
  )
  :trans true))

(define-fun property () Bool (!
  (=> (is-nil curr)
      (= (nth (reverse b) Z) (nth a Z)))
  :invar-property 0))