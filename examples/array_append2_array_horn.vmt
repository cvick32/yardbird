(declare-fun A () (Array Int Int))
(declare-fun A_next () (Array Int Int))
(define-fun .A () (Array Int Int) (! A :next A_next))
(declare-fun I () Int)
(declare-fun I_next () Int)
(define-fun .I () Int (! I :next I_next))
(declare-fun W () Int)
(declare-fun W_next () Int)
(define-fun .W () Int (! W :next W_next))
(declare-fun B () (Array Int Int))
(declare-fun B_next () (Array Int Int))
(define-fun .B () (Array Int Int) (! B :next B_next))
(declare-fun K () Int)
(declare-fun K_next () Int)
(define-fun .K () Int (! K :next K_next))
(declare-fun M () Int)
(declare-fun M_next () Int)
(define-fun .M () Int (! M :next M_next))
(declare-fun N () Int)
(declare-fun N_next () Int)
(define-fun .N () Int (! N :next N_next))
(declare-fun P () Int)
(declare-fun P_next () Int)
(define-fun .P () Int (! P :next P_next))
(declare-fun Q () Int)
(declare-fun Q_next () Int)
(define-fun .Q () Int (! Q :next Q_next))
(declare-fun Z () Int)
(declare-fun Z_next () Int)
(define-fun .Z () Int (! Z :next Z_next))

(define-fun init-conditions () Bool (!
 (and
(= I N)
) :init true))

(define-fun trans-conditions () Bool (!
 (and
(= (store A I W) A_next)
(= (+ I 1) I_next)
(< I (+ N M))
(= W (select B (- I N)))
(= B B_next)
(= K K_next)
(= M M_next)
(= N N_next)
(= P P_next)
(= Q Q_next)
(= Z Z_next)
) :trans true))

(define-fun property () Bool (!
 (and
(let ((a!1 (and (< K (+ N M)) (>= K N) (not (< I (+ N M)))))
      (a!2 (not (= (select A K) (select B (- K N))))))
  (=> a!1 (and (not a!2))))
) :invar-property 0))

